#!/bin/sh

APP_NAME="git-build"
APP_VERSION="v1.0.1"
INSTALLER_URL_CURL="https://curl.haxx.se/download.html"
INSTALLER_URL_GIT="https://git-scm.com/downloads/"
INSTALLER_URL_GEM="https://rubygems.org/pages/download/"
INSTALLER_URL_LARGA="http://172.30.50.113/larga"
INSTALLER_URL_VIM="http://www.vim.org/download.php"
LOG_FILE="/dev/null"
SLACK_WEBHOOK="https://hooks.slack.com/services/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"

# function deploy {
#   if [ -z "$ENVIRONMENT" ]; then
#     die "Cannot deploy: deployment environment not found!"
#   elif [ "$ENVIRONMENT" = "integration" ]; then
#     local subdomain="integration"
#     local endpoint="$subdomain.indinerocorp.com"

#     send_larga_deploy_message "#builds" "<!channel> Deployment to <https://$endpoint|integration> started..."

#     PREVIOUS_BRANCH=`larga -action show -branch placeholder | grep https://$endpoint | awk '{print $1}'`

#     local deployment_action="build"

#     if [ -n "$PREVIOUS_BRANCH" ]; then
#       if [ "$PREVIOUS_BRANCH" = "$BUILD_BRANCH" ]; then
#         deployment_action="deploy"
#       else
#         log_info "Destroying current staging instance $PREVIOUS_BRANCH..."
#         execute_or_die "larga -action destroy -branch $PREVIOUS_BRANCH"
#       fi
#     fi

#     local bundle_command

#     local remote_command="cd /home/deploy/indinero/current; RAILS_ENV=staging /home/deploy/.rbenv/shims/bundle exec"
#     local ssh_options="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
#     log_info "Deploying $BUILD_BRANCH into staging..."

#     if [ "$BUILD_TYPE" = "hotfix" ]; then
#       execute_or_die "larga -action $deployment_action -branch $BUILD_BRANCH"
#     elif [ "$BUILD_TYPE" = "stage" ]; then
#       execute_or_die "larga -action $deployment_action -branch $BUILD_BRANCH -hostname $subdomain -lifespan 3d"
#     else
#       die "Cannot deploy: unknown branch type $BUILD_TYPE"
#     fi

#     bundle_command="script/delayed_job start"
#     execute_or_die "ssh $ssh_options deploy@$subdomain.indinerocorp.com 'sh -l -c \"$remote_command $bundle_command\"'"

#     bundle_command="rake ey_deploy:announce_deployment_end[integration]"
#     execute_or_die "ssh $ssh_options deploy@$subdomain.indinerocorp.com 'sh -l -c \"$remote_command $bundle_command\"'"

#     if [ "$BUILD_TYPE" = "stage" ]; then
#       # Added nohup
#       remote_command="cd /home/deploy/indinero/current; RAILS_ENV=staging nohup /home/deploy/.rbenv/shims/bundle exec"
#       bundle_command="rake ey_deploy:run_outstanding_tasks[integration] &>/dev/null &"
#       execute_or_die "ssh $ssh_options deploy@$subdomain.indinerocorp.com 'sh -l -c \"$remote_command $bundle_command\"'"
#     fi
#   elif [ "$ENVIRONMENT" = "production" ]; then
#     if [ "$BUILD_TYPE" = "hotfix" ] || [ "$BUILD_TYPE" = "release" ]; then
#       execute_or_die "ey login"

#       execute_or_die "git checkout develop"
#       execute_or_die "git merge --no-edit --no-ff $BUILD_BRANCH"
#       execute_or_die "git push origin develop"

#       execute_or_die "git checkout master"
#       execute_or_die "git merge --no-edit --no-ff $BUILD_BRANCH"
#       execute_or_die "git push origin master"

#       if [ "$BUILD_TYPE" = "release" ]; then
#         execute_or_die "git tag $VERSION"
#         execute_or_die "git push origin $VERSION"
#       fi

#       execute_or_die "ey deploy -e indinero3_production -m 'rake db:migrate' -r master"
#     else
#       die "Cannot deploy: unknown branch type $BUILD_TYPE"
#     fi
#   elif [ "$ENVIRONMENT" = "staging" ]; then
#     if [ "$BUILD_TYPE" = "release" ]; then
#       execute_or_die "ey login"
#       execute_or_die "ey deploy -e staging_v3 -m 'rake db:migrate' -r $BUILD_BRANCH"
#     else
#       die "Cannot deploy: unknown branch type $BUILD_TYPE"
#     fi
#   else
#     die "Cannot deploy: unknown deployment environment $ENVIRONMENT"
#   fi
# }

function autogenerate_build_branch {
  case "$ACTION" in
    add-to)
      BUILD_BRANCH="$BUILD_TYPE/$VERSION"
      ;;
    deploy)
      case "$BUILD_TYPE" in
        production)
          BUILD_BRANCH="master"
          ;;
        *)
          BUILD_BRANCH="$BUILD_TYPE/$VERSION"
          ;;
      esac
      ;;
    finish)
      case "$BUILD_TYPE" in
        bugfix)
          BUILD_BRANCH="hotfix/$VERSION"
          ;;
        feature)
          BUILD_BRANCH="develop"
          ;;
        patch)
          if eval "echo '$VERSION' | grep -E -q -w '.+\.0'"; then
            BUILD_BRANCH="release/$VERSION"
          else
            BUILD_BRANCH="hotfix/$VERSION"
          fi
          ;;
        *)
          BUILD_BRANCH="$BUILD_TYPE/$VERSION"
          ;;
      esac
      ;;
    start)
      case "$BUILD_TYPE" in
        integration)
          local version=`date +%y.%-m.%-d.%-H.%-M`
          BUILD_BRANCH="integration/$version"
          ;;
        *)
          BUILD_BRANCH="$BUILD_TYPE/$VERSION"
          ;;
      esac
      ;;
    update)
      BUILD_BRANCH="$BUILD_TYPE/$VERSION"
      ;;
  esac
}

function die {
  if [ -z "$1" ]; then
    echo "$APP_NAME $APP_VERSION"
    echo "================"
    echo "Usage: git-build [options...]"
    echo ""
    echo "Options:"
    echo "  -a|--action STRING"
    echo "\tOperation to perform: add-to, deploy, finish, start, update (REQUIRED)"
    echo "  -b|--branch STRING"
    echo "\tBranch name; overrides -v|--version"
    echo "  -e|--environment STRING"
    echo "\tDestination environment: larga, production, staging (on deploy; REQUIRED for hotfix and integration)"
    echo "  -f|--from STRING"
    echo "\tParent branch (on start; REQUIRED for integration)"
    echo "  -i|--input-file STRING"
    echo "\tList of feature branches to build (REQUIRED except on deploy, finish hotfix, finish release and update release)"
    echo "  -o|--output-file STRING"
    echo "\tOverride the auto-generated filename for the log file"
    echo "  -t|--type STRING"
    echo "\tType of branch to build or deploy: bugfix, feature, hotfix, integration, production, release (REQUIRED)"
    echo "  -v|--version YY.M.D"
    echo "\tVersion number (REQUIRED)"
    echo ""
  else
    log_error $@
    echo "$APP_NAME: (1) $@"
  fi

  exit 1
}

function die_on_existing_branch {
  if git branch -r | grep -q $1; then
    die "Branch $1 already exists"
  fi
}

function die_on_invalid_build_type {
  if [ -z $BUILD_TYPE ]; then
    die "Type not found"
  elif [ -z $1 ] || ! eval "echo $BUILD_TYPE | grep -E -q -w '$1'"; then
    die "Cannot $ACTION build $BUILD_TYPE"
  fi
}

function die_on_invalid_branch_or_version {
  local branch_or_version="$BRANCH"

  if [ -z $branch_or_version ]; then
    branch_or_version="$VERSION"
  fi

  if [ "$BUILD_TYPE" = "hotfix" ] && eval "echo '$branch_or_version' | grep -E -q -w '.+\.0'"; then
    die "Invalid branch or version $branch_or_version"
  elif [ "$BUILD_TYPE" = "release" ] && eval "echo '$branch_or_version' | grep -E -q -v -w '.+\.0'"; then
    die "Invalid branch or version $branch_or_version"
  fi
}

function die_on_invalid_environment {
  if [ -z $ENVIRONMENT ]; then
    die "Environment not found"
  elif [ "$ENVIRONMENT" = "test" ]; then
    > /dev/null # do nothing
  elif [ -z $1 ] || ! eval "echo '$ENVIRONMENT' | grep -E -q -w '$1'"; then
    die "Invalid environment $ENVIRONMENT"
  fi
}

function die_on_invalid_larga {
  if ! eval "type larga > /dev/null"; then
    die "Larga not found; download the latest from $INSTALLER_URL_LARGA"
  elif eval "larga -action show -branch placeholder | grep -q 'DEPRECATION NOTICE' > /dev/null"; then
    die "Larga is outdated; download the latest from $INSTALLER_URL_LARGA"
  fi
}

function die_on_invalid_parent_branch {
  if [ -z $FROM ]; then
    die "Parent branch not found"
  elif [ -z $1 ] || ! eval "echo $FROM | grep -E -q -w '$1'"; then
    die "Cannot branch from parent branch $FROM"
  fi
}

function die_on_missing_branch {
  if ! git branch -r | grep -q "origin/$1"; then
    die "Branch $1 does not exist"
  fi
}

function die_on_missing_curl {
  if ! eval "type curl > /dev/null"; then
    die "Curl not found! Download the latest from $INSTALLER_URL_CURL"
  fi
}

function die_on_missing_engineyard {
  if ! eval "gem list -i engineyard > /dev/null"; then
    die "EngineYard gem not found! Download the latest with 'gem install engineyard'"
  fi
}

function die_on_missing_gem {
  if ! eval "type gem > /dev/null"; then
    die "RubyGems not found! Download the latest from $INSTALLER_URL_GEM"
  fi
}

function die_on_missing_git {
  if ! eval "type git > /dev/null"; then
    die "Git not found; download the installer from $INSTALLER_URL_GIT"
  fi
}

function die_on_missing_input_branches {
  if [ -z "$INPUT_FILE" ] || [ ! -f "$INPUT_FILE" ]; then
    local timestamp=`date +%y%m%d%H%M%S`
    INPUT_FILE="$timestamp-$ACTION-$BUILD_TYPE.txt"

    echo "" > $INPUT_FILE
    echo "# Please enter the list of input branches." >> $INPUT_FILE
    echo "# Lines starting with '#' will be ignored," >> $INPUT_FILE
    echo "# and an empty message aborts the script." >> $INPUT_FILE

    vim $INPUT_FILE
  fi

  INPUT_BRANCHES=`sed 's/#.*$//' $INPUT_FILE | grep -E -v "^[[:space:]]*$" | awk '{print $1}'`
  if [ -z "$INPUT_BRANCHES" ]; then
    die "Input branch(es) not found"
  fi

  local branch
  for branch in $INPUT_BRANCHES; do
    die_on_missing_branch $branch
    git branch -D $branch > /dev/null 2>&1
  done
}

function die_on_missing_branch_or_version {
  if [ -z "$BRANCH" ] && [ -z "$VERSION" ]; then
    die "Branch or version not found"
  fi
}

function die_on_missing_vim {
  if [ -z "$INPUT_FILE" ] || [ ! -f "$INPUT_FILE" ]; then
    if ! eval "type vim > /dev/null"; then
      die "Vim not found; download the installer from $INSTALLER_URL_VIM"
    fi
  fi
}

function execute {
  log_info $@

  raw_output=$(eval $@ 2>&1)
  return_code=$?

  while read -r line_output; do
    log_debug $line_output
  done <<< "$raw_output"
}

function execute_or_die {
  execute $1

  if [ $return_code -ne 0 ]; then
    if [ $# -eq 1 ]; then
      die "git-build encountered an error and cannot proceed! (status code: $?)"
    fi

    shift
    die $@
  fi
}

function initialize_branch_lists {
  MERGED_BRANCHES=()
  UNMERGED_BRANCHES=()
  UNREBASED_BRANCHES=()
}

function initialize_files {
  CLEANUP_FILE="cleanup-$ACTION-$BUILD_TYPE.sh"
  >> $CLEANUP_FILE # Create the cleanup file, if it does not yet exist
  chmod +x $CLEANUP_FILE

  if [ "$LOG_FILE" = "/dev/null" ]; then
    LOG_FILE="$ACTION-$BUILD_TYPE.log"
  fi
}

# function initialize_local_branches {
#   log_info "# Cleaning / setting up local branches"

#   if [ $ACTION = "append" ]; then
#     execute_or_die "git checkout develop"

#     execute "git branch -D $BUILD_BRANCH"
#     execute_or_die "git checkout $BUILD_BRANCH"
#   elif [ $ACTION = "create" ]; then
#     if [ "$BUILD_TYPE" = "hotfix" ]; then
#       execute_or_die "git checkout develop"

#       execute "git branch -D master"
#       execute_or_die "git checkout master"

#       execute_or_die "git checkout -b $BUILD_BRANCH"
#     else
#       execute_or_die "git checkout master"

#       execute "git branch -D develop"
#       execute_or_die "git checkout develop"

#       execute_or_die "git checkout -b $BUILD_BRANCH"
#     fi
#   elif [ $ACTION = "deploy" ]; then
#     execute_or_die "git checkout master"

#     execute "git branch -D develop"
#     execute_or_die "git checkout develop"

#     execute "git branch -D $BUILD_BRANCH"
#     execute_or_die "git checkout $BUILD_BRANCH"

#     execute "git branch -D master"
#     execute_or_die "git checkout master"
#   fi

#   if [ ${#INPUT_BRANCHES[@]} -ne 0 ]; then
#     for branch in $INPUT_BRANCHES; do
#       execute "git branch -D $branch"
#       execute_or_die "git checkout $branch"
#     done
#   fi
# }

function log_cleanup {
  echo $@ >> $CLEANUP_FILE
}

function log_debug {
  echo "\x1B[90m[DEBUG] git-build>    $@\x1B[39m" | tee -a $LOG_FILE
}

function log_error {
  echo "\x1B[31m[ERROR] git-build> $@\x1B[39m" | tee -a $LOG_FILE
}

function log_info {
  echo "[INFO ] git-build> $@" | tee -a $LOG_FILE
}

function log_warn {
  echo "\x1B[31m[WARN ] git-build> $@\x1B[39m" | tee -a $LOG_FILE
}

function merge_or_abort {
  log_info "# Merging $1 to $2"
  execute "git merge --no-edit --no-ff $1"

  if [ $return_code -ne 0 ]; then
    log_warn "# Merge conflict detected for $1"
    execute_or_die "git merge --abort"
    log_info ""

    UNMERGED_BRANCHES+=($1)
    return_code=1
  else
    log_info "# Successfully merged $1 to $2"
    log_info ""

    MERGED_BRANCHES+=($1)
    return_code=0
  fi
}

function parse_cli_arguments {
  local option

  ACTION=""
  BRANCH=""
  BUILD_TYPE=""
  ENVIRONMENT=""
  FROM=""
  INPUT_FILE=""
  VERSION=""

  while [[ $# -gt 0 ]]; do
    option="$1"
    shift

    case "$option" in
      -a|--action)
        ACTION="$1"
        ;;
      -b|--branch)
        BRANCH="$1"
        ;;
      -e|--environment)
        ENVIRONMENT="$1"
        ;;
      -f|--from)
        FROM="$1"
        ;;
      -i|--input-file)
        INPUT_FILE="$1"
        ;;
      -o|--output-file)
        LOG_FILE="$1"
        ;;
      -t|--type)
        BUILD_TYPE="$1"
        ;;
      -v|--version)
        VERSION="$1"
        ;;
      *) # unknown option
        ;;
    esac

    shift
  done
}

function perform_add_to {
  initialize_branch_lists
  log_info "# Adding branch(es) to $BUILD_BRANCH via $APP_NAME $APP_VERSION..."
  execute_or_die "git checkout $BUILD_BRANCH"

  local branch
  for branch in $INPUT_BRANCHES; do
    execute_or_die "git checkout $branch"
    merge_or_abort $branch $BUILD_BRANCH
  done
}

function perform_deploy {
  log_info "# Deploying $BUILD_BRANCH on $ENVIRONMENT via $APP_NAME $APP_VERSION..."

  if [ "$ENVIRONMENT" = "test" ]; then
    log_info "# Successfully deployed $BUILD_BRANCH on $APP_NAME test environment."
  else
    case "$BUILD_TYPE" in
      production)
        ENVIRONMENT="production"
        ;;
      release)
        ENVIRONMENT="staging"
        ;;
    esac

    log_info "# Successfully deployed $BUILD_BRANCH on $ENVIRONMENT."
  fi
}

function perform_finish {
  initialize_branch_lists
  case "$BUILD_TYPE" in
    bugfix)
      log_info "# Merging bugfix(es) into $BUILD_BRANCH via $APP_NAME $APP_VERSION..."
      ;;
    feature)
      log_info "# Merging feature(s) into $BUILD_BRANCH via $APP_NAME $APP_VERSION..."
      ;;
    hotfix)
      log_info "# Merging $BUILD_BRANCH into master and develop via $APP_NAME $APP_VERSION..."
      ;;
    patch)
      log_info "# Merging patch(es) into $BUILD_BRANCH via $APP_NAME $APP_VERSION..."
      ;;
    release)
      log_info "# Merging $BUILD_BRANCH into master and develop via $APP_NAME $APP_VERSION..."
      ;;
  esac

  case "$BUILD_TYPE" in
    bugfix|feature|patch)
      local branch
      for branch in $INPUT_BRANCHES; do
        rebase_and_merge_or_abort $branch $BUILD_BRANCH
      done

      execute_or_die "git push origin $BUILD_BRANCH"
      ;;
    hotfix|release)
      execute_or_die "git checkout $BUILD_BRANCH"

      execute_or_die "git checkout master"
      merge_or_abort $BUILD_BRANCH "master"

      if [ ${#MERGED_BRANCHES[@]} -eq 1 ]; then
        execute_or_die "git push origin master"

        execute_or_die "git checkout develop"
        merge_or_abort $BUILD_BRANCH "develop"
      fi

      if [ ${#MERGED_BRANCHES[@]} -eq 2 ]; then
        execute_or_die "git push origin develop"

        ACTION="deploy"
        BUILD_TYPE="production"

        if [ "$ENVIRONMENT" != "test" ]; then
          ENVIRONMENT="production"
        fi

        perform_deploy
      fi

      ;;
  esac
}

function perform_start {
  log_info "# Creating $BUILD_BRANCH via $APP_NAME $APP_VERSION..."

  case "$BUILD_TYPE" in
    hotfix)
      execute_or_die "git checkout master"
      execute_or_die "git checkout -b $BUILD_BRANCH"

      ACTION="finish"
      BUILD_TYPE="bugfix"

      perform_finish
      ;;
    integration)
      if eval "echo '$BUILD_BRANCH' | grep -E -q -w '.+\.0'"; then
        execute_or_die "git checkout develop"
      else
        execute_or_die "git checkout master"
      fi
      execute_or_die "git checkout -b $BUILD_BRANCH"

      ACTION="add-to"
      BUILD_TYPE="integration"

      perform_add_to
      ;;
    release)
      execute_or_die "git checkout develop"
      execute_or_die "git checkout -b $BUILD_BRANCH"

      ACTION="finish"
      BUILD_TYPE="feature"

      perform_finish
      ;;
  esac
}

function perform_update {
  log_info "# Updating $BUILD_BRANCH via $APP_NAME $APP_VERSION..."
}

function rebase_and_merge_or_abort {
  log_info "# Rebasing $1 to $2"
  execute_or_die "git checkout $2"
  execute "git rebase $2 $1"

  if [ $return_code -ne 0 ]; then
    log_warn "# Rebase conflict detected for $1"
    execute_or_die "git rebase --abort"
    log_info ""

    UNREBASED_BRANCHES+=($1)
  else
    log_info "# Successfully rebased $1 to $2"
    log_info ""

    merge_or_abort $1 $2

    if [ $return_code -eq 0 ]; then
      execute_or_die "git push --force-with-lease origin $1"
    fi
  fi
}

# function send_larga_deploy_message {
#   local channel="\"channel\":\"$1\""
#   shift

#   local icon="\"icon_emoji\":\":engineyard:\""
#   local text="\"text\":\"$@\""
#   local user="\"username\":\"ey-deploy\""

#   curl -X POST -d payload="{$channel,$icon,$text,$user}" $SLACK_WEBHOOK
# }

# function show_cleanup {
#   local branch random=$(( $RANDOM % 3 ))

#   log_cleanup "git checkout develop"

#   for branch in $INPUT_BRANCHES; do
#     log_cleanup "git branch -D $branch"
#   done

#   log_cleanup "git branch -D $BUILD_BRANCH"
#   log_cleanup "rm $CLEANUP_FILE"

#   log_info "# Undo or cleanup this build with the following command:"
#   log_info "#   ./$CLEANUP_FILE"
#   log_info ""

#   if [ $random -eq 1 ]; then
#     log_info "# May the odds be ever in your favor!"
#   elif [ $random -eq 2 ]; then
#     log_info "# May the force be with you!"
#   else
#     log_info "# Good luck, soldier!"
#   fi
# }

# function show_merge_conflicts {
#   local branch
#   if [ ${#UNMERGED_BRANCHES[@]} -gt 0 ]; then
#     log_warn "# The following branches have NOT been merged to $BUILD_BRANCH:"
#     for branch in ${UNMERGED_BRANCHES[@]}; do
#       log_warn "#   $branch"
#     done
#     log_warn "# To add these branches, use the '-a append' option after fixing the merge conflict(s)."
#     log_warn ""
#   fi
# }

# function show_rebase_conflicts {
#   local branch
#   if [ ${#UNREBASED_BRANCHES[@]} -gt 0 ]; then
#     log_warn "# The following branches have NOT been rebased to $BUILD_BRANCH:"
#     for branch in ${UNREBASED_BRANCHES[@]}; do
#       log_warn "#   $branch"
#     done
#     log_warn ""
#     log_warn "# To add these branches, use the '-a append' option after fixing the rebase conflict(s)."
#     log_warn ""
#   fi
# }

function validate_build_branch {
  BUILD_BRANCH="$BRANCH"

  if [ -z $BUILD_BRANCH ]; then
    autogenerate_build_branch
  fi

  if ! eval "git fetch origin"; then
    die "Unable to fetch from origin"
  fi

  case "$ACTION" in
    add-to|deploy|finish|update)
      die_on_missing_branch $BUILD_BRANCH
      ;;
    start)
      die_on_existing_branch $BUILD_BRANCH
      ;;
  esac

  git branch -D $BUILD_BRANCH > /dev/null 2>&1
}

function validate_cli_arguments {
  if [ -z "$ACTION" ]; then
    die "Action not found"
  fi

  case "$ACTION" in
    add-to)
      die_on_invalid_build_type "integration"
      die_on_missing_branch_or_version
      ;;
    deploy)
      case "$BUILD_TYPE" in
        hotfix)
          die_on_invalid_environment "larga|staging"
          die_on_missing_branch_or_version
          die_on_invalid_branch_or_version
          ;;
        integration)
          die_on_invalid_environment "larga|staging"
          die_on_missing_branch_or_version
          ;;
        production)
          BRANCH="master"
          ;;
        release)
          die_on_missing_branch_or_version
          die_on_invalid_branch_or_version
          ;;
        *)
          die_on_invalid_build_type ""
          ;;
      esac
      ;;
    finish)
      die_on_invalid_build_type "bugfix|feature|hotfix|patch|release"
      if [ "$BUILD_TYPE" != "feature" ]; then
        die_on_missing_branch_or_version
        die_on_invalid_branch_or_version
      fi
      ;;
    start)
      die_on_invalid_build_type "hotfix|integration|release"

      if [ "$BUILD_TYPE" = "integration" ]; then
        die_on_invalid_parent_branch "develop|master"
      else
        die_on_missing_branch_or_version
        die_on_invalid_branch_or_version
      fi
      ;;
    update)
      die_on_invalid_build_type "release"
      die_on_missing_branch_or_version
      die_on_invalid_branch_or_version
      ;;
    *)
      die "Invalid action $ACTION"
      ;;
  esac
}

function validate_dependencies {
  die_on_missing_git

  case "$ACTION" in
    add-to|start)
      die_on_missing_vim
      ;;
    deploy)
      case "$BUILD_TYPE" in
        hotfix|integration)
          case "$ENVIRONMENT" in
            larga)
              die_on_invalid_larga
              die_on_missing_curl
              ;;
            staging)
              die_on_missing_gem
              die_on_missing_engineyard
              ;;
          esac
          ;;
        production|release)
          die_on_missing_gem
          die_on_missing_engineyard
          ;;
      esac
      ;;
    finish)
      case "$BUILD_TYPE" in
        bugfix|feature|patch)
          die_on_missing_vim
          ;;
      esac
      ;;
  esac
}

function validate_input_branches {
  case "$ACTION" in
    add-to|start)
      die_on_missing_input_branches
      ;;
    finish)
      case "$BUILD_TYPE" in
        bugfix|feature|patch)
          die_on_missing_input_branches
          ;;
      esac
      ;;
  esac
}

#   # If not provided, auto-generate VERSION based on ACTION and BRANCH
#   if [ -z $VERSION ]; then
#     if [ "$BUILD_TYPE" = "stage" ]; then
#       # Use current date
#       VERSION=`date +%y.%-m.%-d`
#     elif [[ "$BUILD_TYPE" = "release" && ("$ACTION" != "deploy" || "$ENVIRONMENT" = "staging") ]]; then
#       # Use next Monday, except if run on Monday before 12PM, in which case, use current Monday
#       local year_and_month=`date -v +12H -v +Mon +%y.%-m`
#       local week_of_month=$((($(date -v +12H -v +Mon +%-d)-1)/7+1))

#       VERSION="$year_and_month.$week_of_month"
#     else
#       # Use previous Monday, except if run on Monday after 12PM Monday, in which case, use current Monday
#       local year_and_month=`date -v +12H -v -Mon +%y.%-m`
#       local week_of_month=$((($(date -v +12H -v -Mon +%-d)-1)/7+1))

#       VERSION="$year_and_month.$week_of_month"
#     fi
#   fi

#   # always ignore flag for release branches
#   if [ "$BUILD_TYPE" != "release" ]; then
#     if [ $FLAG -ne 0 ]; then
#       VERSION="$VERSION.$FLAG"
#     elif [ "$BUILD_TYPE" = "hotfix" ]; then
#       die # non-zero FLAG is required if BRANCH = hotfix
#     fi
#   fi

#   BUILD_BRANCH="$BUILD_TYPE/$VERSION"

parse_cli_arguments $@
validate_cli_arguments
validate_dependencies
validate_input_branches
validate_build_branch

initialize_files # actual logging starts here

case "$ACTION" in
  add-to)
    perform_add_to
    ;;
  deploy)
    perform_deploy
    ;;
  finish)
    perform_finish
    ;;
  start)
    perform_start
    ;;
  update)
    perform_update
    ;;
esac

echo "OK"

# initialize_local_branches

# if [ $ACTION = "deploy" ]; then
#   deploy
# else
#   MERGED_BRANCHES=()
#   UNMERGED_BRANCHES=()
#   UNREBASED_BRANCHES=()

#   if [ "$BUILD_TYPE" = "stage" ]; then
#     for branch in $INPUT_BRANCHES; do
#       merge_or_abort $branch $BUILD_BRANCH
#     done
#   else
#     for branch in $INPUT_BRANCHES; do
#       rebase_and_merge_or_abort $branch $BUILD_BRANCH
#     done
#   fi

#   execute_or_die "git push origin $BUILD_BRANCH"

#   show_rebase_conflicts
#   show_merge_conflicts
#   show_cleanup
# fi
