#!/bin/sh

APP_NAME="git-build"
APP_VERSION="v1.0.1"
INSTALLER_URL_CURL="https://curl.haxx.se/download.html"
INSTALLER_URL_GIT="https://git-scm.com/downloads/"
INSTALLER_URL_GEM="https://rubygems.org/pages/download/"
INSTALLER_URL_LARGA="http://172.30.50.113/larga"
INSTALLER_URL_VIM="http://www.vim.org/download.php"
LOG_FILE="/dev/null"
SLACK_WEBHOOK="https://hooks.slack.com/services/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"

# function deploy {
#   if [ -z "$ENVIRONMENT" ]; then
#     die "Cannot deploy: deployment environment not found!"
#   elif [ "$ENVIRONMENT" = "integration" ]; then
#     local subdomain="integration"
#     local endpoint="$subdomain.indinerocorp.com"

#     send_larga_deploy_message "#builds" "<!channel> Deployment to <https://$endpoint|integration> started..."

#     PREVIOUS_BRANCH=`larga -action show -branch placeholder | grep https://$endpoint | awk '{print $1}'`

#     local deployment_action="build"

#     if [ -n "$PREVIOUS_BRANCH" ]; then
#       if [ "$PREVIOUS_BRANCH" = "$BUILD_BRANCH" ]; then
#         deployment_action="deploy"
#       else
#         log_info "Destroying current staging instance $PREVIOUS_BRANCH..."
#         execute_or_die "larga -action destroy -branch $PREVIOUS_BRANCH"
#       fi
#     fi

#     local bundle_command

#     local remote_command="cd /home/deploy/indinero/current; RAILS_ENV=staging /home/deploy/.rbenv/shims/bundle exec"
#     local ssh_options="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
#     log_info "Deploying $BUILD_BRANCH into staging..."

#     if [ "$BUILD_TYPE" = "hotfix" ]; then
#       execute_or_die "larga -action $deployment_action -branch $BUILD_BRANCH"
#     elif [ "$BUILD_TYPE" = "stage" ]; then
#       execute_or_die "larga -action $deployment_action -branch $BUILD_BRANCH -hostname $subdomain -lifespan 3d"
#     else
#       die "Cannot deploy: unknown branch type $BUILD_TYPE"
#     fi

#     bundle_command="script/delayed_job start"
#     execute_or_die "ssh $ssh_options deploy@$subdomain.indinerocorp.com 'sh -l -c \"$remote_command $bundle_command\"'"

#     bundle_command="rake ey_deploy:announce_deployment_end[integration]"
#     execute_or_die "ssh $ssh_options deploy@$subdomain.indinerocorp.com 'sh -l -c \"$remote_command $bundle_command\"'"

#     if [ "$BUILD_TYPE" = "stage" ]; then
#       # Added nohup
#       remote_command="cd /home/deploy/indinero/current; RAILS_ENV=staging nohup /home/deploy/.rbenv/shims/bundle exec"
#       bundle_command="rake ey_deploy:run_outstanding_tasks[integration] &>/dev/null &"
#       execute_or_die "ssh $ssh_options deploy@$subdomain.indinerocorp.com 'sh -l -c \"$remote_command $bundle_command\"'"
#     fi
#   elif [ "$ENVIRONMENT" = "production" ]; then
#     if [ "$BUILD_TYPE" = "hotfix" ] || [ "$BUILD_TYPE" = "release" ]; then
#       execute_or_die "ey login"

#       execute_or_die "git checkout develop"
#       execute_or_die "git merge --no-edit --no-ff $BUILD_BRANCH"
#       execute_or_die "git push origin develop"

#       execute_or_die "git checkout master"
#       execute_or_die "git merge --no-edit --no-ff $BUILD_BRANCH"
#       execute_or_die "git push origin master"

#       if [ "$BUILD_TYPE" = "release" ]; then
#         execute_or_die "git tag $VERSION"
#         execute_or_die "git push origin $VERSION"
#       fi

#       execute_or_die "ey deploy -e indinero3_production -m 'rake db:migrate' -r master"
#     else
#       die "Cannot deploy: unknown branch type $BUILD_TYPE"
#     fi
#   elif [ "$ENVIRONMENT" = "staging" ]; then
#     if [ "$BUILD_TYPE" = "release" ]; then
#       execute_or_die "ey login"
#       execute_or_die "ey deploy -e staging_v3 -m 'rake db:migrate' -r $BUILD_BRANCH"
#     else
#       die "Cannot deploy: unknown branch type $BUILD_TYPE"
#     fi
#   else
#     die "Cannot deploy: unknown deployment environment $ENVIRONMENT"
#   fi
# }

function die {
  if [ -z "$1" ]; then
    echo "$APP_NAME $APP_VERSION"
    echo "================"
    echo "Usage: git-build [options...]"
    echo ""
    echo "Options:"
    echo "  -a|--action STRING"
    echo "\tOperation to perform: add-to, deploy, finish, start, update (REQUIRED)"
    echo "  -b|--branch STRING"
    echo "\tBranch name; overrides -v|--version (and -f|--flag, if applicable)"
    echo "  -e|--environment STRING"
    echo "\tDestination environment: larga, production, staging (on deploy; REQUIRED for hotfix and integration)"
    echo "  -f|--flag INTEGER"
    echo "\tNon-zero incrementing flag"
    echo "  -i|--input-file STRING"
    echo "\tList of feature branches to build (REQUIRED except on deploy, finish hotfix, finish release and update release)"
    echo "  -t|--type STRING"
    echo "\tType of branch to build or deploy: bugfix, feature, hotfix, integration, production, release (REQUIRED)"
    echo "  -v|--version YY.M.D"
    echo "\tVersion number (REQUIRED)"
    echo ""
  else
    log_error $@
    echo "$APP_NAME: (1) $@"
  fi

  exit 1
}

function die_on_invalid_build_type {
  if [ -z $BUILD_TYPE ]; then
    die "Type not found"
  elif [ -z $1 ] || ! eval "echo $BUILD_TYPE | grep -E -w '$1' > /dev/null"; then
    die "Cannot $ACTION build $BUILD_TYPE"
  fi
}

function die_on_invalid_branch_or_version {
  local branch_or_version="$BRANCH"

  if [ -z $branch_or_version ]; then
    branch_or_version="$VERSION"
  fi

  if [ "$BUILD_TYPE" = "hotfix" ] && eval "echo '$branch_or_version' | grep -E -w '.+\.0' > /dev/null"; then
    die "Invalid branch or version $branch_or_version"
  elif [ "$BUILD_TYPE" = "release" ] && eval "echo '$branch_or_version' | grep -E -v -w '.+\.0' > /dev/null"; then
    die "Invalid branch or version $branch_or_version"
  fi
}

function die_on_invalid_environment {
  if [ -z $ENVIRONMENT ]; then
    die "Environment not found"
  elif [ -z $1 ] || ! eval "echo '$ENVIRONMENT' | grep -E -w '$1' > /dev/null"; then
    die "Invalid environment $ENVIRONMENT"
  fi
}

function die_on_invalid_input_branches {
  if [ -z "$INPUT_FILE" ] || [ ! -f "$INPUT_FILE" ]; then
    local timestamp=`date +%y%m%d%H%M%S`
    INPUT_FILE="$timestamp-$ACTION-$BUILD_TYPE.txt"

    echo "" > $INPUT_FILE
    echo "# Please enter the list of feature branches to be deployed." >> $INPUT_FILE
    echo "# Lines starting with '#' will be ignored, and an empty message aborts the script." >> $INPUT_FILE

    vim $INPUT_FILE
  fi

  INPUT_BRANCHES=`sed 's/#.*$//' $INPUT_FILE | grep -E -v "^[[:space:]]*$" | awk '{print $1}'`
  if [ -z "$INPUT_BRANCHES" ]; then
    die "Input branch(es) not found"
  fi
}

function die_on_invalid_larga {
  if ! eval "type larga > /dev/null"; then
    die "Larga not found; download the latest from $INSTALLER_URL_LARGA"
  elif eval "larga -action show -branch placeholder | grep -q 'DEPRECATION NOTICE' > /dev/null"; then
    die "Larga is outdated; download the latest from $INSTALLER_URL_LARGA"
  fi
}

function die_on_missing_curl {
  if ! eval "type curl > /dev/null"; then
    die "Curl not found! Download the latest from $INSTALLER_URL_CURL"
  fi
}

function die_on_missing_engineyard {
  if ! eval "gem list -i engineyard > /dev/null"; then
    die "EngineYard gem not found! Download the latest with 'gem install engineyard'"
  fi
}

function die_on_missing_gem {
  if ! eval "type gem > /dev/null"; then
    die "RubyGems not found! Download the latest from $INSTALLER_URL_GEM"
  fi
}

function die_on_missing_git {
  if ! eval "type git > /dev/null"; then
    die "Git not found; download the installer from $INSTALLER_URL_GIT"
  fi
}

function die_on_missing_input_file {
  if [ -z "$INPUT_FILE" ] || [ ! -f "$INPUT_FILE" ]; then
    die "Input file $INPUT_FILE not found"
  fi
}

function die_on_missing_branch_or_version {
  if [ -z "$BRANCH" ] && [ -z "$VERSION" ]; then
    die "Branch or version not found"
  fi
}

function die_on_missing_vim {
  if [ -z "$INPUT_FILE" ] || [ ! -f "$INPUT_FILE" ]; then
    if ! eval "type vim > /dev/null"; then
      die "Vim not found; download the installer from $INSTALLER_URL_VIM"
    fi
  fi
}

# function execute {
#   log_info $@

#   raw_output=$(eval $@ 2>&1)
#   return_code=$?

#   while read -r line_output; do
#     log_debug $line_output
#   done <<< "$raw_output"
# }

# function execute_or_die {
#   execute $1

#   if [ $return_code -ne 0 ]; then
#     if [ $# -eq 1 ]; then
#       die "git-build encountered an error and cannot proceed! (status code: $?)"
#     fi

#     shift
#     die $@
#   fi
# }

# function initialize_files {
#   CLEANUP_FILE="cleanup-$BUILD_TYPE-$VERSION.sh"
#   >> $CLEANUP_FILE # Create the cleanup file, if it does not yet exist
#   chmod +x $CLEANUP_FILE

#   LOG_FILE="$BUILD_TYPE-$VERSION.log"
#   if [ $ACTION = "append" ]; then
#     echo "" > $LOG_FILE # Insert a blank line, to separate log entries per "session"

#     local action="Appending to"
#   elif [ $ACTION = "create" ]; then
#     > $LOG_FILE # Create a blank log file

#     local action="Creating"
#   fi

#   log_info "# $action $BUILD_BRANCH via $APP_NAME $APP_VERSION"
# }

# function initialize_local_branches {
#   log_info "# Cleaning / setting up local branches"

#   if [ $ACTION = "append" ]; then
#     execute_or_die "git checkout develop"

#     execute "git branch -D $BUILD_BRANCH"
#     execute_or_die "git checkout $BUILD_BRANCH"
#   elif [ $ACTION = "create" ]; then
#     if [ "$BUILD_TYPE" = "hotfix" ]; then
#       execute_or_die "git checkout develop"

#       execute "git branch -D master"
#       execute_or_die "git checkout master"

#       execute_or_die "git checkout -b $BUILD_BRANCH"
#     else
#       execute_or_die "git checkout master"

#       execute "git branch -D develop"
#       execute_or_die "git checkout develop"

#       execute_or_die "git checkout -b $BUILD_BRANCH"
#     fi
#   elif [ $ACTION = "deploy" ]; then
#     execute_or_die "git checkout master"

#     execute "git branch -D develop"
#     execute_or_die "git checkout develop"

#     execute "git branch -D $BUILD_BRANCH"
#     execute_or_die "git checkout $BUILD_BRANCH"

#     execute "git branch -D master"
#     execute_or_die "git checkout master"
#   fi

#   if [ ${#INPUT_BRANCHES[@]} -ne 0 ]; then
#     for branch in $INPUT_BRANCHES; do
#       execute "git branch -D $branch"
#       execute_or_die "git checkout $branch"
#     done
#   fi
# }

function log_cleanup {
  echo $@ >> $CLEANUP_FILE
}

function log_debug {
  echo "\x1B[90m[DEBUG] git-build>    $@\x1B[39m" | tee -a $LOG_FILE
}

function log_error {
  echo "\x1B[31m[ERROR] git-build> $@\x1B[39m" | tee -a $LOG_FILE
}

function log_info {
  echo "[INFO ] git-build> $@" | tee -a $LOG_FILE
}

function log_warn {
  echo "\x1B[31m[WARN ] git-build> $@\x1B[39m" | tee -a $LOG_FILE
}

# function merge_or_abort {
#   log_info "# Merging $1 to $2"
#   execute_or_die "git checkout $2"
#   execute "git merge --no-edit --no-ff $1"

#   if [ $return_code -ne 0 ]; then
#     log_warn "# Merge conflict detected for $1"
#     execute_or_die "git merge --abort"
#     log_info ""

#     UNMERGED_BRANCHES+=($1)
#     merge_success=false
#   else
#     log_info "# Successfully merged $1 to $2"
#     log_info ""

#     MERGED_BRANCHES+=($1)
#     merge_success=true
#   fi
# }

function parse_cli_arguments {
  local option

  ACTION=""
  BRANCH=""
  BUILD_TYPE=""
  ENVIRONMENT=""
  FLAG=""
  INPUT_FILE=""
  VERSION=""

  while [[ $# -gt 0 ]]; do
    option="$1"
    shift

    case $option in
      -a|--action)
        ACTION="$1"
        ;;
      -b|--branch)
        BRANCH="$1"
        ;;
      -e|--environment)
        ENVIRONMENT="$1"
        ;;
      -f|--flag)
        FLAG="$1"
        ;;
      -i|--input-file)
        INPUT_FILE="$1"
        ;;
      -t|--type)
        BUILD_TYPE="$1"
        ;;
      -v|--version)
        VERSION="$1"
        ;;
      *) # unknown option
        ;;
    esac

    shift
  done
}

# function parse_feature_branches {
#   # Get input file, if applicable; generate one, otherwise.
#   if [ -z $INPUT_FILE]; then
#     INPUT_FILE="feature-branches-$BUILD_TYPE-$VERSION.txt"
#     echo "" > $INPUT_FILE
#     echo "# Please enter the list of feature branches to be deployed." >> $INPUT_FILE
#     echo "# Lines starting with '#' will be ignored, and an empty message aborts the script." >> $INPUT_FILE
#     vim $INPUT_FILE

#     log_cleanup "rm -f $INPUT_FILE"
#   fi

#   INPUT_BRANCHES=`sed 's/#.*$//' $INPUT_FILE | grep -E -v "^[[:space:]]*$" | awk '{print $1}'`
#   if [ ${#INPUT_BRANCHES[@]} -eq 0 ]; then
#     die "No feature branches found!"
#   fi
# }

# function rebase_and_merge_or_abort {
#   log_info "# Rebasing $1 to $2"
#   execute_or_die "git checkout $1"
#   execute "git rebase $2"

#   if [ $return_code -ne 0 ]; then
#     log_warn "# Rebase conflict detected for $1"
#     execute_or_die "git rebase --abort"
#     log_info ""

#     UNREBASED_BRANCHES+=($1)
#   else
#     log_info "# Successfully rebased $1 to $2"
#     log_info ""

#     merge_or_abort $1 $2

#     if [ "$merge_success" = true ]; then
#       execute_or_die "git push --force-with-lease origin $1"
#     fi
#   fi
# }

# function send_larga_deploy_message {
#   local channel="\"channel\":\"$1\""
#   shift

#   local icon="\"icon_emoji\":\":engineyard:\""
#   local text="\"text\":\"$@\""
#   local user="\"username\":\"ey-deploy\""

#   curl -X POST -d payload="{$channel,$icon,$text,$user}" $SLACK_WEBHOOK
# }

# function show_cleanup {
#   local branch random=$(( $RANDOM % 3 ))

#   log_cleanup "git checkout develop"

#   for branch in $INPUT_BRANCHES; do
#     log_cleanup "git branch -D $branch"
#   done

#   log_cleanup "git branch -D $BUILD_BRANCH"
#   log_cleanup "rm $CLEANUP_FILE"

#   log_info "# Undo or cleanup this build with the following command:"
#   log_info "#   ./$CLEANUP_FILE"
#   log_info ""

#   if [ $random -eq 1 ]; then
#     log_info "# May the odds be ever in your favor!"
#   elif [ $random -eq 2 ]; then
#     log_info "# May the force be with you!"
#   else
#     log_info "# Good luck, soldier!"
#   fi
# }

# function show_merge_conflicts {
#   local branch
#   if [ ${#UNMERGED_BRANCHES[@]} -gt 0 ]; then
#     log_warn "# The following branches have NOT been merged to $BUILD_BRANCH:"
#     for branch in ${UNMERGED_BRANCHES[@]}; do
#       log_warn "#   $branch"
#     done
#     log_warn "# To add these branches, use the '-a append' option after fixing the merge conflict(s)."
#     log_warn ""
#   fi
# }

# function show_rebase_conflicts {
#   local branch
#   if [ ${#UNREBASED_BRANCHES[@]} -gt 0 ]; then
#     log_warn "# The following branches have NOT been rebased to $BUILD_BRANCH:"
#     for branch in ${UNREBASED_BRANCHES[@]}; do
#       log_warn "#   $branch"
#     done
#     log_warn ""
#     log_warn "# To add these branches, use the '-a append' option after fixing the rebase conflict(s)."
#     log_warn ""
#   fi
# }

function validate_cli_arguments {
  if [ -z "$ACTION" ]; then
    die "Action not found"
  fi

  case $ACTION in
    add-to)
      die_on_invalid_build_type "integration"
      die_on_missing_branch_or_version
      ;;
    deploy)
      case $BUILD_TYPE in
        hotfix|integration)
          die_on_invalid_environment "larga|staging"
          ;;
        production)
          ENVIRONMENT="production"
          ;;
        release)
          ENVIRONMENT="staging"
          ;;
        *)
          die_on_invalid_build_type ""
          ;;
      esac
      ;;
    finish)
      die_on_invalid_build_type "bugfix|feature|hotfix|patch|release"
      if [ "$BUILD_TYPE" != "feature" ]; then
        die_on_missing_branch_or_version
        die_on_invalid_branch_or_version
      fi
      ;;
    start)
      die_on_invalid_build_type "hotfix|integration|release"
      die_on_missing_branch_or_version
      die_on_invalid_branch_or_version
      ;;
    update)
      die_on_invalid_build_type "release"
      die_on_missing_branch_or_version
      die_on_invalid_branch_or_version
      ;;
    *)
      die "Invalid action $ACTION"
      ;;
  esac
}


function validate_dependencies {
  case $ACTION in
    add-to)
      die_on_missing_git
      die_on_missing_vim
      ;;
    deploy)
      case $BUILD_TYPE in
        hotfix|integration)
          case $ENVIRONMENT in
            larga)
              die_on_invalid_larga
              die_on_missing_curl
              ;;
            staging)
              die_on_missing_gem
              die_on_missing_engineyard
              ;;
          esac
          ;;
        production|release)
          die_on_missing_gem
          die_on_missing_engineyard
          ;;
      esac
      ;;
    finish)
      die_on_missing_git
      case $BUILD_TYPE in
        bugfix|feature|patch)
          die_on_missing_vim
          ;;
      esac
      ;;
    start)
      die_on_missing_git
      die_on_missing_vim
      ;;
    update)
      die_on_missing_git
      ;;
  esac
}

function validate_input_branches {
  case $ACTION in
    add-to|start)
      die_on_invalid_input_branches
      ;;
    finish)
      case $BUILD_TYPE in
        bugfix|feature|patch)
          die_on_invalid_input_branches
          ;;
      esac
      ;;
  esac
}

#   # If not provided, auto-generate VERSION based on ACTION and BRANCH
#   if [ -z $VERSION ]; then
#     if [ "$BUILD_TYPE" = "stage" ]; then
#       # Use current date
#       VERSION=`date +%y.%-m.%-d`
#     elif [[ "$BUILD_TYPE" = "release" && ("$ACTION" != "deploy" || "$ENVIRONMENT" = "staging") ]]; then
#       # Use next Monday, except if run on Monday before 12PM, in which case, use current Monday
#       local year_and_month=`date -v +12H -v +Mon +%y.%-m`
#       local week_of_month=$((($(date -v +12H -v +Mon +%-d)-1)/7+1))

#       VERSION="$year_and_month.$week_of_month"
#     else
#       # Use previous Monday, except if run on Monday after 12PM Monday, in which case, use current Monday
#       local year_and_month=`date -v +12H -v -Mon +%y.%-m`
#       local week_of_month=$((($(date -v +12H -v -Mon +%-d)-1)/7+1))

#       VERSION="$year_and_month.$week_of_month"
#     fi
#   fi

#   # always ignore flag for release branches
#   if [ "$BUILD_TYPE" != "release" ]; then
#     if [ $FLAG -ne 0 ]; then
#       VERSION="$VERSION.$FLAG"
#     elif [ "$BUILD_TYPE" = "hotfix" ]; then
#       die # non-zero FLAG is required if BRANCH = hotfix
#     fi
#   fi

#   BUILD_BRANCH="$BUILD_TYPE/$VERSION"

parse_cli_arguments $@
validate_cli_arguments
validate_dependencies
validate_input_branches

echo "OK"

# initialize_files # actual logging starts here

# execute_or_die "git fetch origin"
# if git branch -r | grep -q $BUILD_BRANCH; then
#   if [ $ACTION = "create" ]; then
#     die "Cannot create already-existing branch: $BUILD_BRANCH"
#   fi
# elif [ $ACTION = "append" ]; then
#   die "Cannot append to non-existent branch: $BUILD_BRANCH"
# elif [ $ACTION = "deploy" ]; then
#   die "Cannot deploy non-existent branch: $BUILD_BRANCH"
# fi

# if [ $ACTION != "deploy" ]; then
#   parse_feature_branches $@
# fi

# initialize_local_branches

# if [ $ACTION = "deploy" ]; then
#   deploy
# else
#   MERGED_BRANCHES=()
#   UNMERGED_BRANCHES=()
#   UNREBASED_BRANCHES=()

#   if [ "$BUILD_TYPE" = "stage" ]; then
#     for branch in $INPUT_BRANCHES; do
#       merge_or_abort $branch $BUILD_BRANCH
#     done
#   else
#     for branch in $INPUT_BRANCHES; do
#       rebase_and_merge_or_abort $branch $BUILD_BRANCH
#     done
#   fi

#   execute_or_die "git push origin $BUILD_BRANCH"

#   show_rebase_conflicts
#   show_merge_conflicts
#   show_cleanup
# fi